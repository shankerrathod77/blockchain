'use strict';

const { Contract } = require('fabric-contract-api');

class LandRecordContract extends Contract {
    async Init(ctx) {
        console.info('Smart contract instantiated');
    }

    async createLandRequest(ctx, receipt_number, dataJson) {
        const exists = await ctx.stub.getState(receipt_number);
        if (exists && exists.length > 0) {
            throw new Error(`Land request with receipt number ${receipt_number} already exists`);
        }

        const data = JSON.parse(dataJson);
        data.history = [];
        await ctx.stub.putState(receipt_number, Buffer.from(JSON.stringify(data)));
        return `Land request ${receipt_number} created successfully`;
    }

    async readLandRequest(ctx, receipt_number) {
        const buffer = await ctx.stub.getState(receipt_number);
        if (!buffer || buffer.length === 0) {
            throw new Error(`Land request ${receipt_number} does not exist`);
        }
        return buffer.toString();
    }

    async updateLandStatus(ctx, receipt_number, newStatus, assignedTo, remarks, fromUser, timestamp) {
        const buffer = await ctx.stub.getState(receipt_number);
        if (!buffer || buffer.length === 0) {
            throw new Error(`Land request ${receipt_number} does not exist`);
        }
    
        const land = JSON.parse(buffer.toString());
        land.status = newStatus;
        land.currently_with = assignedTo;
    
        const entry = {
            timestamp: timestamp, // âœ… passed from client
            from_user: fromUser,
            to_user: assignedTo,
            action: newStatus,
            remarks: remarks
        };
    
        if (!land.history) {
            land.history = [];
        }
        land.history.push(entry);
    
        await ctx.stub.putState(receipt_number, Buffer.from(JSON.stringify(land)));
        return `Land request ${receipt_number} updated with status ${newStatus}`;
    }
    

    async getAllLandRequests(ctx) {
        const iterator = await ctx.stub.getStateByRange('', '');
        const results = [];

        while (true) {
            const res = await iterator.next();
            if (res.value && res.value.value.toString()) {
                const record = JSON.parse(res.value.value.toString());
                results.push(record);
            }
            if (res.done) break;
        }

        return JSON.stringify(results);
    }
}

module.exports = LandRecordContract;




----------landcontract.js



// landcontract.js
'use strict';

const { Gateway, Wallets } = require('fabric-network');
const fs = require('fs');
const path = require('path');

const ccpPath = path.resolve(__dirname, 'connection-org1.json');
const ccp = JSON.parse(fs.readFileSync(ccpPath, 'utf8'));

async function connect() {
    const walletPath = path.join(__dirname, 'wallet');
    const wallet = await Wallets.newFileSystemWallet(walletPath);

    const gateway = new Gateway();
    await gateway.connect(ccp, {
        wallet,
        identity: 'admin',
        discovery: { enabled: true, asLocalhost: true },
    });

    const network = await gateway.getNetwork('mychannel');
    const contract = network.getContract('landrecords');
    return { contract, gateway };
}

async function getAllLandRequests() {
    const { contract, gateway } = await connect();
    const result = await contract.evaluateTransaction('getAllLandRequests');
    await gateway.disconnect();
    return JSON.parse(result.toString());
}

async function createLandRequest(receiptNumber, data) {
    const { contract, gateway } = await connect();
    const response = await contract.submitTransaction(
        'createLandRequest',
        receiptNumber,
        JSON.stringify(data)
    );
    await gateway.disconnect();
    return response.toString();
}

async function updateLandStatus(receiptNumber, newStatus, assignedTo, remarks, fromUser, timestamp) {
    const { contract, gateway } = await connect();
    const response = await contract.submitTransaction(
        'updateLandStatus',
        receiptNumber,
        newStatus,
        assignedTo,
        remarks,
        fromUser,
        timestamp
    );
    await gateway.disconnect();
    return response.toString();
}

module.exports = {
    getAllLandRequests,
    createLandRequest,
    updateLandStatus,
};





pina--------------

    import requests

# Fabric API base URL (your existing Fabric API server)
FABRIC_API_URL = "http://localhost:3000/api/landrequests"

# Pinata API keys (replace with your actual keys)
PINATA_API_KEY = "your-pinata-api-key"
PINATA_API_SECRET = "your-pinata-api-secret"


def get_all_land_requests():
    try:
        response = requests.get(FABRIC_API_URL)
        response.raise_for_status()
        return response.json()
    except requests.RequestException as e:
        return {"error": str(e)}

def create_land_request(receipt_number, data):
    payload = {
        "receiptNumber": receipt_number,
        "data": data
    }
    try:
        response = requests.post(f"{FABRIC_API_URL}/create", json=payload)
        response.raise_for_status()
        return response.json()
    except requests.RequestException as e:
        return {"error": str(e)}

def update_land_status(receipt_number, new_status, assigned_to, remarks, from_user, timestamp):
    payload = {
        "receiptNumber": receipt_number,
        "newStatus": new_status,
        "assignedTo": assigned_to,
        "remarks": remarks,
        "fromUser": from_user,
        "timestamp": timestamp
    }
    try:
        response = requests.post(f"{FABRIC_API_URL}/update", json=payload)
        response.raise_for_status()
        return response.json()
    except requests.RequestException as e:
        return {"error": str(e)}

# --- New function to upload file to Pinata IPFS ---
def upload_file_to_pinata(file_path, file_name='file.pdf'):
    url = "https://api.pinata.cloud/pinning/pinFileToIPFS"
    headers = {
        "pinata_api_key": "62729d62efb35e949fc2",
        "pinata_secret_api_key": "e409206ed2526e4d0649d795de01bdd409b5f85d5c1538fee4816764eed091ab"
    }

    with open(file_path, 'rb') as f:
        files = {'file': (file_name, f)}
        response = requests.post(url, files=files, headers=headers)

    if response.status_code == 200:
        return response.json()['IpfsHash']
    else:
        raise Exception(f"Pinata upload failed: {response.text}")



